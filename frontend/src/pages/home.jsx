import React, {useState, useEffect} from 'react'
//useState manages data, useEffect runs sideEffects.
// useEffect(() => { ... }, [ ]) → Runs only once on mount
// useEffect(() => { ... }, [someState]) → Runs when someState changes
//and useState will be used to change the state.
import { Card, Loader, FormField} from "../components/index"

const RenderCards =({data, title})=>{
  if(data?.length > 0) {
    return data.map((post)=> <Card key={post._id} {...post}></Card>) //passing all of post's properties as prop to the card component.
  }

  return (
    <h2 className='mt-5 font-bold text-[#6449ff] text-xl uppercase'>
      {title}
    </h2>
  )
}
const home = () => {
  const [loading, setLoading] = useState(false);//loading will be set to false initially
  const [allPosts, setAllPosts] = useState(null); //i.e initial value of all posts will be null(we'll fetch them from an api or database)
  const [searchText, setsearchText] = useState('');
  const [searchedResults, setSearchedResults] = useState(null);
  const [searchTimeout, setsearchTimeout] = useState(null);
  //LOADING ALL GENERATED IMAGES INTO THE HOME COMPONENT AS OF YET.
  useEffect(()=>{
    const fetchPosts = async ()=>{
      setLoading(true);
      try {
        const response = await fetch('http://localhost:8080/api/v1/post', {
          method: 'GET',
          'Content-Type': 'application/json',

        });
        
        if(response.ok){
          const result = await response.json();
          
          setAllPosts(result.data.reverse()); //reversed them just to show the recent ones first.
        }
      }catch(error) {
        alert(error);
      }finally {
        setLoading(false);//when either of the two(try or catch) happen, set loading to false.
      }
    }
    fetchPosts();//calling it right away as we need to load the images.
  }, [])//since we're passing nothing, our useEffect will act as componentDidMount, i.e when home component Mounts the callback will be executed
  //we could pass state, prop, or any variable in the dependency array but then callback will only execute when there's a change in that value.
  //we can pass multiple variables, and when either of them changes the useEffect hook will call the callback.


  const handleSearchChange = (e)=>{
    clearTimeout(searchTimeout);//clear prev timeout on a key button press.(what we want to do is, if user presses a key before 500milisec, then the timer should start again!)
    setsearchText(e.target.value);//update the searchText's value on each keystroke

    //now wait for 500 milisec before you finalize SearchedResults, but if a key is pressed before 500milsec then you have to clearTimeout and start the cycle once again.(and input field will be cleared by the onClick of the button)
    setsearchTimeout(
    setTimeout(()=>{
      const searchResults = allPosts.filter((item)=>item.name.toLowerCase().includes(searchText.toLowerCase()) 
      || item.prompt.toLowerCase().includes(searchText.toLowerCase()))
  
      setSearchedResults(searchResults);


    }, 500) //using setTimeout so that we do not keep updating the state at each key stroke, instead we wait for some time(like 500milisec)
    );
  }//now we can pass this function in our input(through Formfield as props in the code below)

  return (
    <section className="max-w-7xl mx-auto">
      <div>
        <h1 className="font-extrabold text-[#222328] text-[32px]">The Community Showcase</h1>
          <p className = "mt-2 text-[#666e75] text-[16px] max-w-[500px]">
            Browse through visually stunning imges generated by Dall-e AI
          </p>
      </div>
      <div className='mt-16'>
        <FormField 
        LabelName="Search Posts"
        type="text"
        name="text"
        placeholder="Search Posts"
        value={searchText}
        handleChange={handleSearchChange}
        />
      </div>
      <div className='mt-10'>
        {loading ? (
          <div className="flex justify-center items-center">
            <Loader />
          </div>
        ): (
          <>
          {searchText && (
            <h2 className='font-medium text-[#555e75] text-xl mb-3'>
              <span className="text-[#222328]">Showing Results for: {searchText}</span>
            </h2>
          )}
          <div className='grid lg:grid-cols-4 sm:grid-cols-3 xs:grid-cols-2 grid-cols-1 gap-3'>
            {searchText ? (
              <RenderCards data={searchedResults} title="No search results found" />
            ): 
            <RenderCards data={allPosts} title="No posts found" />
            }

          </div>
          </>
        )}
      </div>
    </section>
  )
}

export default home


//rafce (and enter gives you boilerplate simple functional component)